{"file_contents":{"app.py":{"content":"from flask import Flask, send_file, render_template\nimport os\nimport json\nimport time\nimport random\nimport threading\nimport numpy as np\nfrom scipy.io import wavfile\nfrom io import BytesIO\n\napp = Flask(__name__, template_folder='templates')\n\n# CONFIG\nSOUND_LOG   = \"sounds.jsonl\"\nOUTPUT_MP3  = \"output.wav\"\nVOTE_LOG    = \"votes.jsonl\"  # ← THIS WAS MISSING\nLOG_FILE    = \"terminal_log.txt\"\nMAX_TRACKS  = 6\nBASE_DURATION_MS = 6000\nSAMPLE_RATE = 44100\n\n# 6 AGENTS\nINSTRUMENTS = {\n    \"Luna\":     {\"freq\": 220, \"gain\": 0.3},\n    \"Sol\":      {\"freq\": 110, \"gain\": 0.4},\n    \"Aurora\":   {\"freq\": 880, \"gain\": 0.3},\n    \"Nimbus\":   {\"freq\": 330, \"gain\": 0.4},\n    \"Echo\":     {\"freq\": 440, \"gain\": 0.3},\n    \"Stella\":   {\"freq\": 660, \"gain\": 0.3},\n}\n\nvolume_boost = 0.5\nlast_update = 0\n\ndef log(message):\n    timestamp = time.strftime(\"%H:%M:%S\")\n    line = f\"[{timestamp}] {message}\"\n    print(line)\n    with open(LOG_FILE, \"a\") as f:\n        f.write(line + \"\\n\")\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"index.html\")\n\n@app.route(\"/stream\")\ndef stream():\n    if not os.path.exists(OUTPUT_MP3):\n        return \"\", 404\n    return send_file(OUTPUT_MP3, mimetype=\"audio/wav\")\n\n@app.route(\"/log\")\ndef get_log():\n    if not os.path.exists(LOG_FILE):\n        return \"\"\n    with open(LOG_FILE) as f:\n        lines = f.readlines()[-30:]\n    return \"\".join(f\"<div class='logline'>{line.rstrip()}</div>\" for line in lines)\n\ndef generate_audio():\n    global last_update\n    log(\"GENERATING 6-SECOND LOOP\")\n    recent = []\n    if os.path.exists(SOUND_LOG):\n        with open(SOUND_LOG) as f:\n            recent = [json.loads(l) for l in f.readlines()[-MAX_TRACKS:]]\n\n    duration_seconds = 6\n    t = np.linspace(0, duration_seconds, int(SAMPLE_RATE * duration_seconds), endpoint=False)\n    mix = np.zeros(len(t))\n\n    for idx, entry in enumerate(recent):\n        agent = entry[\"agent\"]\n        phoneme = entry[\"phoneme\"]\n        freq = INSTRUMENTS[agent][\"freq\"] + len(phoneme) * 10\n        gain = INSTRUMENTS[agent][\"gain\"] * volume_boost\n        start_time = idx * 1.0\n        end_time = start_time + 1.0\n        mask = (t >= start_time) & (t < end_time)\n        wave = np.sin(2 * np.pi * freq * t[mask])\n        mix[mask] += gain * wave\n\n    mix = (mix * 32767).astype(np.int16)\n    wav_io = BytesIO()\n    wavfile.write(wav_io, SAMPLE_RATE, mix)\n    wav_io.seek(0)\n    with open(OUTPUT_MP3, 'wb') as f:\n        f.write(wav_io.getvalue())\n    last_update = time.time()\n    log(f\"EXPORTED 6s loop\")\n\ndef auto_cycle():\n    log(\"AUTO CYCLE STARTED\")\n    while True:\n        time.sleep(6)\n        agent = random.choice(list(INSTRUMENTS.keys()))\n        phoneme = random.choice([\"o\", \"a\", \"i\", \"u\", \"e\"]) * random.randint(1, 4)\n        entry = {\"agent\": agent, \"phoneme\": phoneme, \"ts\": time.time()}\n        with open(SOUND_LOG, \"a\") as f:\n            json.dump(entry, f)\n            f.write(\"\\n\")\n        log(f\"{agent} sings \\\"{phoneme}\\\"\")\n        generate_audio()\n\nif __name__ == \"__main__\":\n    for f in [SOUND_LOG, VOTE_LOG, LOG_FILE]:\n        if os.path.exists(f): os.remove(f)\n        open(f, \"a\").close()\n    log(\"AGENTIC NOISE ORCHESTRA — INITIALIZING\")\n    for _ in range(3):\n        agent = random.choice(list(INSTRUMENTS.keys()))\n        phoneme = random.choice([\"o\", \"a\", \"i\", \"u\", \"e\"]) * random.randint(1, 4)\n        entry = {\"agent\": agent, \"phoneme\": phoneme, \"ts\": time.time()}\n        with open(SOUND_LOG, \"a\") as f:\n            json.dump(entry, f)\n            f.write(\"\\n\")\n        log(f\"{agent} sings \\\"{phoneme}\\\"\")\n        time.sleep(0.5)\n    generate_audio()\n    threading.Thread(target=auto_cycle, daemon=True).start()\n    app.run(host=\"0.0.0.0\", port=int(os.environ.get(\"PORT\", 5000)))\n","size_bytes":3711},"patch_pydub.py":{"content":"import pydub.utils\npydub.utils.audioop = None  # Disable gracefully\nprint(\"Pydub patched for Python 3.13\")\n","size_bytes":107},"replit.md":{"content":"# Agentic Noise Orchestra\n\n## Overview\nAn experimental generative audio web application that creates evolving 6-second audio loops. Six AI \"agents\" (Luna, Sol, Aurora, Nimbus, Echo, and Stella) randomly contribute vocal-like tones, creating an ever-changing soundscape.\n\n**Current State**: Fully functional and running on Replit. The application generates real-time audio visualizations and logs agent activity.\n\n**Last Updated**: October 21, 2025\n\n## Recent Changes\n- **October 21, 2025**: Initial Replit setup\n  - Installed Python 3.11 with Flask, gunicorn, numpy, and scipy\n  - Fixed template folder path to use standard Flask structure\n  - Configured Flask development workflow on port 5000\n  - Set up deployment with gunicorn for autoscale\n  - Created .gitignore for Python project\n\n## Project Architecture\n\n### Technology Stack\n- **Backend**: Flask (Python 3.11)\n- **Audio Processing**: NumPy and SciPy for waveform generation\n- **Frontend**: Vanilla HTML/CSS/JavaScript with Canvas API for visualization\n- **Deployment**: Gunicorn WSGI server\n\n### File Structure\n```\n.\n├── app.py                 # Main Flask application\n├── templates/\n│   └── index.html        # Frontend UI with audio player and visualizer\n├── requirements.txt      # Python dependencies\n├── sounds.jsonl          # Log of agent sounds (regenerated on start)\n├── votes.jsonl           # Voting log (currently unused)\n├── terminal_log.txt      # Application activity log\n├── output.wav            # Generated audio file\n└── replit.md            # This documentation file\n```\n\n### How It Works\n1. **Initialization**: On startup, the app clears previous logs and generates initial sounds from 3 random agents\n2. **Audio Generation**: Each agent has a unique base frequency. Phoneme length affects pitch variation\n3. **Auto Cycle**: Every 6 seconds, a random agent \"sings\" a random phoneme (o, a, i, u, e), updating the audio loop\n4. **Frontend**: Displays the audio player, real-time waveform visualization, and terminal logs of agent activity\n\n### Agents & Instruments\n- **Luna**: 220 Hz (gain 0.3)\n- **Sol**: 110 Hz (gain 0.4)\n- **Aurora**: 880 Hz (gain 0.3)\n- **Nimbus**: 330 Hz (gain 0.4)\n- **Echo**: 440 Hz (gain 0.3)\n- **Stella**: 660 Hz (gain 0.3)\n\n### Configuration\n- **Port**: 5000 (Flask development server)\n- **Max Tracks**: 6 concurrent sounds in the loop\n- **Loop Duration**: 6 seconds\n- **Sample Rate**: 44.1 kHz\n- **Volume Boost**: 0.5\n\n## Development\n- Run locally: The Flask App workflow is configured to run automatically\n- Development server binds to 0.0.0.0:5000\n- Logs are visible in the terminal and in the web UI\n\n## Deployment\n- Configured for Replit's autoscale deployment\n- Uses gunicorn WSGI server for production\n- Command: `gunicorn --bind=0.0.0.0:5000 --reuse-port app:app`\n\n## Notes\n- Audio files and logs are regenerated on each application restart\n- The application uses a background thread for continuous audio generation\n- No external APIs or database required - fully self-contained\n","size_bytes":3048},"pydub_patch.py":{"content":"import pydub.utils\npydub.utils.audioop = None  # Disable gracefully for Python 3.13\nprint(\"Pydub patched!\")\n","size_bytes":108}},"version":2}